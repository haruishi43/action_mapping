<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Action Mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			a { color: skyblue }
			.button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
			.highlight { background:orange; color:#fff; }
			span {
				display: inline-block;
				width: 60px;
				float: left;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<script src="http://code.jquery.com/jquery-latest.js"></script>
		<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.5/socket.io.min.js"></script>
		<script src="{{ url_for('static', filename='js/three.js') }}"></script>

        <script src="{{ url_for('static', filename='js/libs/stats.min.js') }}"></script>
		<script src="{{ url_for('static', filename='js/libs/dat.gui.min.js') }}"></script>
		<script src="{{ url_for('static', filename='js/loaders/PLYLoader.js') }}"></script>
		<!-- <script src="{{ url_for('static', filename='js/controls/TrackballControls.js') }}"></script> -->
		<script src="{{ url_for('static', filename='js/controls/OrbitControls.js') }}"></script> 
        <script src="{{ url_for('static', filename='js/Detector.js') }}"></script>
		<script src="{{ url_for('static', filename='js/script.js') }}"></script>
		
		<!-- <script type="text/javascript" charset="utf-8">
			// testing socketio
			var socket = io.connect('http://' + document.domain + ':' + location.port);
			
			socket.on('connect', function() {
				socket.emit('my event', {data: 'I\'m connected!'});
			});

			socket.on('my response', function( msg ) {
				console.log( msg );
			});

		</script> -->

		<script>
			var socket = io.connect('http://' + document.domain + ':' + location.port);

			socket.on ('connect', function() {
				socket.emit ('my event', {data: 'I\'m connected!'});
			});
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			// Global Variables
			var container, stats, gui;
			var scene, renderGroup, camera, renderer, orbit, lights;
			var last = 0; // timestamp of the last render() call
			var lastClear = 0; // timestamp of the last render() call
			
			var interval = 0.05; // 1/frame rate
			var jointGroup = [];
			var limbGroup = [];
			var centerGroup = {};

			var jointColors = [
				[255, 0, 0], [255, 85, 0], [255, 170, 0], [255, 255, 0], [170, 255, 0],
				[85, 255, 0], [0, 255, 0], [0, 255, 85], [0, 255, 170], [0, 255, 255],
				[0, 170, 255], [0, 85, 255], [0, 0, 255], [85, 0, 255], [170, 0, 255],
				[255, 0, 255], [255, 0, 170], [255, 0, 85]
			];

			var limbColors = [
				[0, 255, 0], [0, 255, 85], [0, 255, 170], [0, 255, 255], [0, 170, 255],
				[0, 85, 255], [255, 0, 0], [255, 85, 0], [255, 170, 0], [255, 255, 0.],
				[255, 0, 85], [170, 255, 0], [85, 255, 0], [170, 0, 255.], [0, 0, 255],
				[0, 0, 255], [255, 0, 255], [170, 0, 255], [255, 0, 170]
			];

			var limbConnections = [ // connect which joint to which (by index)
				[1, 8], [8, 9], [9, 10], [1, 11], [11, 12], 
				[12, 13], [1, 2], [2, 3], [3, 4], [1, 5], 
				[5, 6], [6, 7], [1, 0], [0, 14], [0, 15], 
				[14, 16], [15, 17]
			];
			
			// Main Room Model
			var roomModelURL = "{{ url_for('static', filename='models/ply/binary/new_room_edited.ply') }}";

			// Font
			//var fontFile = "{{ url_for('static', filename='fonts/helvetiker_regular.typeface.json') }}";

			var state = {
				renderPose : true
			};

			function initHuman() {
				var joints = [];
				var limbs = [];

				// create geometry for joints
				for (var i=0; i<jointColors.length; i++) {
					
					// initialize joint points
					
					var jointColor = jointColors[i];
					var jointColorHex = fullColorHex(jointColor[0], jointColor[1], jointColor[2]);
					jointColorHex = new THREE.Color(parseInt(jointColorHex, 16));

					// var jointGeometry = new THREE.Geometry();
					// var jointMaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false });
					// jointMaterial.color = jointColorHex;
					// jointGeometry.colors = jointColorHex;
					// jointGeometry.computeBoundingBox();
					// var joint = new THREE.Points( jointGeometry, jointMaterial );
					// joint.scale.set( 10,10,10 );
					
					var geometry = new THREE.SphereGeometry( 0.3, 8, 8 );
					var material = new THREE.MeshBasicMaterial( {color: jointColorHex} );
					var joint = new THREE.Mesh(geometry, material);

					
					renderGroup.add(joint);

					joints.push(joint);

				}
				
				for (var j=0; j<limbConnections.length; j++) {
					var connectionPair = limbConnections[j];
					var n1 = connectionPair[0];
					var n2 = connectionPair[1];

					var v1 = joints[n1].position;
					var v2 = joints[n2].position;

					var lineColor = limbColors[j];
					var lineColorHex = fullColorHex(lineColor[0], lineColor[1], lineColor[2]);
					lineColorHex = new THREE.Color(parseInt(lineColorHex, 16));

					var lineGeometry = new THREE.Geometry();
					lineGeometry.vertices.push(v1);
					lineGeometry.vertices.push(v2);
					lineGeometry.dynamic = true;
					lineGeometry.verticesNeedUpdate = true;

					var lineMaterial = new THREE.LineBasicMaterial( { color: lineColorHex, opacity: 0.5, linewidth: 3 } );
					var line = new THREE.Line(lineGeometry, lineMaterial);

					renderGroup.add(line);

					limbs.push(line);
				}

				jointGroup.push(joints);
				limbGroup.push(limbs);
			}

			function createText(text, pos) {
				var canvas1 = document.createElement('canvas');
				canvas1.height = 128;
				canvas1.width = 256;
				var context1 = canvas1.getContext('2d');
				context1.font = "Bold 40px Arial";
				color = jointColors[Math.floor(Math.random()*jointColors.length)];
				context1.fillStyle = "rgba("+color[0]+","+color[1]+","+color[2]+",0.9)";
				context1.fillText(text, 0, 64);
				
				// canvas contents will be used for a texture
				var texture1 = new THREE.Texture(canvas1) 
				texture1.needsUpdate = true;
				
				var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
				material1.transparent = true;
				var mesh1 = new THREE.Mesh(
					new THREE.PlaneGeometry(8, 8),
					material1
				);
				mesh1.position.set(pos[0], pos[1], pos[2]);
				mesh1.rotation.x = Math.PI / 2; 
				renderGroup.add( mesh1 );

				centerGroup[text] = mesh1;
			}

			function updateJoints(index, pose) {
				// call this function when new pose needs to be added
				
				for (var i=0; i<jointColors.length; i++) {
					var id = i.toString();
					if (typeof pose[id] === "undefined") {
						jointGroup[index][i].visible = false;
					}
					else {
						var x = pose[id][0];
						var y = pose[id][1];
						var z = pose[id][2];

						jointGroup[index][i].visible = true;
						jointGroup[index][i].position.set(x, y, z);
					}
				}
				
				// update line
				var ids = Object.keys(pose);
				for (var j=0; j<limbConnections.length; j++) {
					var n1 = limbConnections[j][0].toString();
					var n2 = limbConnections[j][1].toString();

					limbGroup[index][j].geometry.verticesNeedUpdate = true;
					limbGroup[index][j].computeLineDistances();
					if (ids.includes(n1) && ids.includes(n2)) {
						
						limbGroup[index][j].visible = true;
					} else {
						limbGroup[index][j].visible = false;
					}
				}
			}

			function updatePoses(poses) {
				if (typeof poses === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonPoses = JSON.parse(poses);
					var currentPoseCount = Object.keys(jsonPoses).length;
					var posesShouldDisappear = jointGroup.length - currentPoseCount;

					for (var key in jsonPoses) {

						var i = Number(key);
						var pose = jsonPoses[key];

						if (i+1 > jointGroup.length) {
							initHuman();
							console.log("new pose")
						}

						// if (i === 0) {
						// 	// only a single person for now
						// 	updateJoints(i, pose);
						// }
						updateJoints(i, pose);
					}
					
					// make other pose disappear
					for (var i=currentPoseCount; i<jointGroup.length; i++) {
						for (var j=0; j<jointColors.length; j++) {
							jointGroup[i][j].visible = false;
						}
					}

					for (var i=currentPoseCount; i<limbGroup.length; i++) {
						for (var j=0; j<limbConnections.length; j++) {
							limbGroup[i][j].visible = false;
						}
					}

				}
			}

			function updateCenters(centers) {
				if (typeof centers === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonCenters = JSON.parse(centers);

					for (var key in jsonCenters) {
						var center = jsonCenters[key];
						
						if (!(key in centerGroup)) {
							// add text
							createText(key, center);
						}

					}

				}
			}

			function updateBboxes(bboxes) {
				if (typeof bboxes === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonBboxes = JSON.parse(bboxes);
					console.log(jsonBboxes);

					for (var key in jsonBboxes) {

						var i = Number(key);
						var bbox = jsonBboxes[key];
						
					}

				}
			}

			function gotNewDataFromSocket(poses, bboxes, centers) {
				
				updatePoses(poses);
				//updateBboxes(bboxes);
				updateCenters(centers);
			}

			function getDataFromSocket(callback) {
				socket.emit('want pose', {data: 'give me pose'}, callback);
				// socket.once('send pose', function( msg ) {
				// 	ack();
				// 	callback(msg);
				// });
			}

			function animate(now) {  // requestAnimationFrame has a call back for time (which is `now`)
				if(!last || now - last >= interval*1000) {
					last = now;
					if (state.renderPose) {
						getDataFromSocket(gotNewDataFromSocket);
					}
				}

				if(!lastClear || now - lastClear >= 5*1000) {
					lastClear = now;
					
					// clear objects once in a while
					for (var key in centerGroup) {
						renderGroup.remove(centerGroup[key]);
						centerGroup[key].geometry.dispose();
						centerGroup[key].material.dispose();
						centerGroup[key] = undefined;
					}

					centerGroup = {};
				}

				requestAnimationFrame( animate );
				
				renderer.render( scene, camera );
				stats.update();
			}
			

			initThreeD(roomModelURL);
			
			setupDatGui();
			initHuman();
			animate();

		</script>

	</body>
</html>