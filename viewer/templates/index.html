<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Action Mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			a { color: skyblue }
			.button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
			.highlight { background:orange; color:#fff; }
			span {
				display: inline-block;
				width: 60px;
				float: left;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<script src="http://code.jquery.com/jquery-latest.js"></script>
		<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.5/socket.io.min.js"></script>
		<script src="{{ url_for('static', filename='js/three.js') }}"></script>

        <script src="{{ url_for('static', filename='js/libs/stats.min.js') }}"></script>
		<script src="{{ url_for('static', filename='js/libs/dat.gui.min.js') }}"></script>
		<script src="{{ url_for('static', filename='js/loaders/PLYLoader.js') }}"></script>
		<!-- <script src="{{ url_for('static', filename='js/controls/TrackballControls.js') }}"></script> -->
		<script src="{{ url_for('static', filename='js/controls/OrbitControls.js') }}"></script> 
        <script src="{{ url_for('static', filename='js/Detector.js') }}"></script>
		<script src="{{ url_for('static', filename='js/script.js') }}"></script>
		
		<!-- <script type="text/javascript" charset="utf-8">
			// testing socketio
			var socket = io.connect('http://' + document.domain + ':' + location.port);
			
			socket.on('connect', function() {
				socket.emit('my event', {data: 'I\'m connected!'});
			});

			socket.on('my response', function( msg ) {
				console.log( msg );
			});

		</script> -->

		<script>
			var socket = io.connect('http://' + document.domain + ':' + location.port);

			socket.on ('connect', function() {
				socket.emit ('my event', {data: 'I\'m connected!'});
			});
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			// Global Variables
			var container, stats, gui;
			var scene, renderGroup, camera, renderer, orbit, lights;
			var last = 0; // timestamp of the last render() call
			var lastClear = 0; // timestamp of the last render() call
			
			var interval = 0.05; // 1/frame rate
			var jointGroup = [];
			var limbGroup = [];
			var centerGroup = {};

			var jointColors = [
				[255, 0, 0], [255, 85, 0], [255, 170, 0], [255, 255, 0], [170, 255, 0],
				[85, 255, 0], [0, 255, 0], [0, 255, 85], [0, 255, 170], [0, 255, 255],
				[0, 170, 255], [0, 85, 255], [0, 0, 255], [85, 0, 255], [170, 0, 255],
				[255, 0, 255], [255, 0, 170], [255, 0, 85]
			];

			var limbColors = [
				[0, 255, 0], [0, 255, 85], [0, 255, 170], [0, 255, 255], [0, 170, 255],
				[0, 85, 255], [255, 0, 0], [255, 85, 0], [255, 170, 0], [255, 255, 0.],
				[255, 0, 85], [170, 255, 0], [85, 255, 0], [170, 0, 255.], [0, 0, 255],
				[0, 0, 255], [255, 0, 255], [170, 0, 255], [255, 0, 170]
			];

			var limbConnections = [ // connect which joint to which (by index)
				[1, 8], [8, 9], [9, 10], [1, 11], [11, 12], 
				[12, 13], [1, 2], [2, 3], [3, 4], [1, 5], 
				[5, 6], [6, 7], [1, 0], [0, 14], [0, 15], 
				[14, 16], [15, 17]
			];
			
			var coco_label_names = ['background',
				'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
				'fire hydrant', 'street sign', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
				'elephant', 'bear', 'zebra', 'giraffe', 'hat', 'backpack', 'umbrella', 'shoe', 'eye glasses', 'handbag', 'tie', 'suitcase', 'frisbee',
				'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle',
				'plate', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
				'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
				'mirror', 'dining table', 'window', 'desk','toilet', 'door', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
				'toaster', 'sink', 'refrigerator', 'blender', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
			];
			
			var coco_label_colors = {
				1: [1, 0.7, 0],
				2: [0, 0, 0],
				3: [0, 0, 0],
				4: [0, 0, 0],
				5: [0, 0, 0],
				6: [0, 0, 0],
				7: [0, 0, 0],
				8: [0, 0, 0],
				9: [0, 0, 0],
				10: [0, 0, 0],
				11: [0, 0, 0],
				13: [0, 0, 0],
				14: [0, 0, 0],
				15: [0, 0, 0],
				16: [0, 0, 0],
				17: [0, 0, 0],
				18: [0, 0, 0],
				19: [0, 0, 0],
				20: [0, 0, 0],
				21: [0, 0, 0],
				22: [0, 0, 0],
				23: [0, 0, 0],
				24: [0, 0, 0],
				25: [0, 0, 0],
				27: [0.5, 0, 0.5],
				28: [0.3, 0.6, 1],
				31: [0.8, 0, 0.1],
				32: [0, 0.9, 1],
				33: [0.2, 0.2, 1],
				34: [0, 0, 0],
				35: [0, 0, 0],
				36: [0.1, 0.4, 0],
				37: [0, 0, 0],
				38: [0, 0, 0],
				39: [0, 0, 0],
				40: [0, 0, 0],
				41: [0, 0, 0],
				42: [0, 0, 0],
				43: [0, 0, 0],
				44: [0.9, 0.7, 1],
				46: [0, 0.2, 0.6],
				47: [1, 0.4, 0.5],
				48: [0, 0.1, 0.5],
				49: [0.2, 1, 0.2],
				50: [0.4, 0.7, 0.7],
				51: [0, 0, 0.3],
				52: [0, 0.5, 0.1],
				53: [0.1, 0.7, 0.3],
				54: [0.6, 0.5, 0.4],
				53: [0.3, 0.2, 0.1],
				54: [0.1, 0.2, 0.3],
				55: [0.4, 0.5, 0.6],
				56: [0.9, 0.8, 0.7],
				57: [0.6, 0.7, 1],
				58: [0.1, 0.1, 0.3],
				59: [0, 1, 0.5],
				60: [0.5, 0.3, 0.8],
				61: [0.6, 0.3, 0.1],
				62: [0.1, 0.6, 0.8],
				63: [1, 0.2, 0.6],
				64: [1, 0, 0.6],
				65: [0.9, 0.1, 0.9],
				67: [0.8, 0.3, 0.8],
				70: [0.4, 0.3, 0.9],
				72: [0, 0.3, 0.3],
				73: [0, 0.7, 1],
				74: [0, 0.5, 0.5],
				75: [1, 0.3, 0.2],
				76: [0.4, 0.4, 1],
				77: [0.1, 0.4, 0.3],
				78: [0, 0, 0.5],
				79: [0.7, 0.7, 0.3],
				80: [0.4, 0.3, 0],
				81: [0.8, 0.5, 0.3],
				82: [0.6, 0.9, 0.3],
				83: [0.5, 0.6, 0.2],
				84: [0.3, 0.6, 0.6],
				85: [0.9, 0.5, 0.1],
				86: [0.3, 0.5, 0.5],
				87: [1, 1, 0.3],
				88: [0.8, 1, 1],
				89: [0.3, 0.5, 0.3],
				90: [0.7, 0.8, 0.2]
			};

			
			// Main Room Model
			var roomModelURL = "{{ url_for('static', filename='models/ply/binary/new_room_edited.ply') }}";

			// Font
			//var fontFile = "{{ url_for('static', filename='fonts/helvetiker_regular.typeface.json') }}";

			var state = {
				renderPose : true
			};

			function initHuman() {
				var joints = [];
				var limbs = [];

				// create geometry for joints
				for (var i=0; i<jointColors.length; i++) {
					
					// initialize joint points
					
					var jointColor = jointColors[i];
					var jointColorHex = fullColorHex(jointColor[0], jointColor[1], jointColor[2]);
					jointColorHex = new THREE.Color(parseInt(jointColorHex, 16));

					// var jointGeometry = new THREE.Geometry();
					// var jointMaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false });
					// jointMaterial.color = jointColorHex;
					// jointGeometry.colors = jointColorHex;
					// jointGeometry.computeBoundingBox();
					// var joint = new THREE.Points( jointGeometry, jointMaterial );
					// joint.scale.set( 10,10,10 );
					
					var geometry = new THREE.SphereGeometry( 0.3, 8, 8 );
					var material = new THREE.MeshBasicMaterial( {color: jointColorHex} );
					var joint = new THREE.Mesh(geometry, material);

					
					renderGroup.add(joint);

					joints.push(joint);

				}
				
				for (var j=0; j<limbConnections.length; j++) {
					var connectionPair = limbConnections[j];
					var n1 = connectionPair[0];
					var n2 = connectionPair[1];

					var v1 = joints[n1].position;
					var v2 = joints[n2].position;

					var lineColor = limbColors[j];
					var lineColorHex = fullColorHex(lineColor[0], lineColor[1], lineColor[2]);
					lineColorHex = new THREE.Color(parseInt(lineColorHex, 16));

					var lineGeometry = new THREE.Geometry();
					lineGeometry.vertices.push(v1);
					lineGeometry.vertices.push(v2);
					lineGeometry.dynamic = true;
					lineGeometry.verticesNeedUpdate = true;

					var lineMaterial = new THREE.LineBasicMaterial( { color: lineColorHex, opacity: 0.5, linewidth: 3 } );
					var line = new THREE.Line(lineGeometry, lineMaterial);

					renderGroup.add(line);

					limbs.push(line);
				}

				jointGroup.push(joints);
				limbGroup.push(limbs);
			}

			function createText(text, pos) {

				var id_instance = cocoLabelTextToObjectID(text);
				var id = id_instance[0];
				var instance = id_instance[1];
				var name = coco_label_names[id];
				instance = instance.toString();
				name = name + " " + instance;
				var color = coco_label_colors[id.toString()];
				color = color.map(function(i) { return i*255 });
			
				var canvas1 = document.createElement('canvas');
				canvas1.height = 128;
				canvas1.width = 256;
				var context1 = canvas1.getContext('2d');
				context1.font = "Bold 40px Arial";
				context1.fillStyle = "rgba("+color[0]+","+color[1]+","+color[2]+",0.9)";
				context1.fillText(name, 0, 64);
				
				// canvas contents will be used for a texture
				var texture1 = new THREE.Texture(canvas1) 
				texture1.needsUpdate = true;
				
				var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
				material1.transparent = true;
				var mesh1 = new THREE.Mesh(
					new THREE.PlaneGeometry(8, 8),
					material1
				);
				mesh1.position.set(pos[0], pos[1], pos[2]);
				mesh1.rotation.x = Math.PI / 2; 
				renderGroup.add( mesh1 );

				centerGroup[text] = mesh1;
			}

			function updateJoints(index, pose) {
				// call this function when new pose needs to be added
				
				for (var i=0; i<jointColors.length; i++) {
					var id = i.toString();
					if (typeof pose[id] === "undefined") {
						jointGroup[index][i].visible = false;
					}
					else {
						var x = pose[id][0];
						var y = pose[id][1];
						var z = pose[id][2];

						jointGroup[index][i].visible = true;
						jointGroup[index][i].position.set(x, y, z);
					}
				}
				
				// update line
				var ids = Object.keys(pose);
				for (var j=0; j<limbConnections.length; j++) {
					var n1 = limbConnections[j][0].toString();
					var n2 = limbConnections[j][1].toString();

					limbGroup[index][j].geometry.verticesNeedUpdate = true;
					limbGroup[index][j].computeLineDistances();
					if (ids.includes(n1) && ids.includes(n2)) {
						
						limbGroup[index][j].visible = true;
					} else {
						limbGroup[index][j].visible = false;
					}
				}
			}

			function updatePoses(poses) {
				if (typeof poses === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonPoses = JSON.parse(poses);
					var currentPoseCount = Object.keys(jsonPoses).length;
					var posesShouldDisappear = jointGroup.length - currentPoseCount;

					for (var key in jsonPoses) {

						var i = Number(key);
						var pose = jsonPoses[key];

						if (i+1 > jointGroup.length) {
							initHuman();
							console.log("new pose")
						}

						// if (i === 0) {
						// 	// only a single person for now
						// 	updateJoints(i, pose);
						// }
						updateJoints(i, pose);
					}
					
					// make other pose disappear
					for (var i=currentPoseCount; i<jointGroup.length; i++) {
						for (var j=0; j<jointColors.length; j++) {
							jointGroup[i][j].visible = false;
						}
					}

					for (var i=currentPoseCount; i<limbGroup.length; i++) {
						for (var j=0; j<limbConnections.length; j++) {
							limbGroup[i][j].visible = false;
						}
					}

				}
			}

			function updateCenters(centers) {
				if (typeof centers === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonCenters = JSON.parse(centers);

					for (var key in jsonCenters) {
						var center = jsonCenters[key];
						
						if (!(key in centerGroup)) {
							// add text
							createText(key, center);
						}

					}

				}
			}

			function updateBboxes(bboxes) {
				if (typeof bboxes === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonBboxes = JSON.parse(bboxes);
					console.log(jsonBboxes);

					for (var key in jsonBboxes) {

						var i = Number(key);
						var bbox = jsonBboxes[key];
						
					}

				}
			}

			function gotNewDataFromSocket(poses, bboxes, centers) {
				
				updatePoses(poses);
				//updateBboxes(bboxes);
				updateCenters(centers);
			}

			function getDataFromSocket(callback) {
				socket.emit('want pose', {data: 'give me pose'}, callback);
				// socket.once('send pose', function( msg ) {
				// 	ack();
				// 	callback(msg);
				// });
			}

			function animate(now) {  // requestAnimationFrame has a call back for time (which is `now`)
				if(!last || now - last >= interval*1000) {
					last = now;
					if (state.renderPose) {
						getDataFromSocket(gotNewDataFromSocket);
					}
				}

				if(!lastClear || now - lastClear >= 2*1000) {
					lastClear = now;
					
					// clear objects once in a while
					for (var key in centerGroup) {

						// don't clear if the center point is near

						renderGroup.remove(centerGroup[key]);
						centerGroup[key].geometry.dispose();
						centerGroup[key].material.dispose();
						centerGroup[key] = undefined;
					}

					centerGroup = {};
				}

				requestAnimationFrame( animate );
				
				renderer.render( scene, camera );
				stats.update();
			}
			

			initThreeD(roomModelURL);
			
			setupDatGui();
			initHuman();
			animate();

		</script>

	</body>
</html>