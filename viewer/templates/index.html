<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Action Mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			a { color: skyblue }
			.button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
			.highlight { background:orange; color:#fff; }
			span {
				display: inline-block;
				width: 60px;
				float: left;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<script src="http://code.jquery.com/jquery-latest.js"></script>
		<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.5/socket.io.min.js"></script>
		<script src="{{ url_for('static', filename='js/three.js') }}"></script>

        <script src="{{ url_for('static', filename='js/libs/stats.min.js') }}"></script>
		<script src="{{ url_for('static', filename='js/libs/dat.gui.min.js') }}"></script>
		<script src="{{ url_for('static', filename='js/loaders/PLYLoader.js') }}"></script>
		<!-- <script src="{{ url_for('static', filename='js/controls/TrackballControls.js') }}"></script> -->
		<script src="{{ url_for('static', filename='js/controls/OrbitControls.js') }}"></script> 
        <script src="{{ url_for('static', filename='js/Detector.js') }}"></script>
		<script src="{{ url_for('static', filename='js/script.js') }}"></script>
		
		<!-- <script type="text/javascript" charset="utf-8">
			// testing socketio
			var socket = io.connect('http://' + document.domain + ':' + location.port);
			
			socket.on('connect', function() {
				socket.emit('my event', {data: 'I\'m connected!'});
			});

			socket.on('my response', function( msg ) {
				console.log( msg );
			});

		</script> -->

		<script>
			var socket = io.connect('http://' + document.domain + ':' + location.port);

			socket.on ('connect', function() {
				socket.emit ('my event', {data: 'I\'m connected!'});
			});
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			// Global Variables
			var container, stats, gui;
			var scene, renderGroup, camera, renderer, orbit, lights;
			var poses = [];
			var last = 0; // timestamp of the last render() call
			var interval = 0.05; // 1/frame rate

			var jointColors = [
				[255, 0, 0], [255, 85, 0], [255, 170, 0], [255, 255, 0], [170, 255, 0],
				[85, 255, 0], [0, 255, 0], [0, 255, 85], [0, 255, 170], [0, 255, 255],
				[0, 170, 255], [0, 85, 255], [0, 0, 255], [85, 0, 255], [170, 0, 255],
				[255, 0, 255], [255, 0, 170], [255, 0, 85]
			];

			var limbColors = [
				[0, 255, 0], [0, 255, 85], [0, 255, 170], [0, 255, 255], [0, 170, 255],
				[0, 85, 255], [255, 0, 0], [255, 85, 0], [255, 170, 0], [255, 255, 0.],
				[255, 0, 85], [170, 255, 0], [85, 255, 0], [170, 0, 255.], [0, 0, 255],
				[0, 0, 255], [255, 0, 255], [170, 0, 255], [255, 0, 170]
			];

			var limbConnections = [ // connect which joint to which (by index)
				[1, 8], [8, 9], [9, 10], [1, 11], [11, 12], 
				[12, 13], [1, 2], [2, 3], [3, 4], [1, 5], 
				[5, 6], [6, 7], [1, 0], [0, 14], [0, 15], 
				[14, 16], [15, 17]
			];

			var jointGroup = [];
			var limbGroup = [];

			// var totalJoints = 18;

			// var geometry = new THREE.BufferGeometry();

			// var positions = new Float32Array( totalJoints * 3);
			// geometry.addAttribute( 'position', new THREE.BufferAttribute( postion));
			
			
			// Main Room Model
			var roomModelURL = "{{ url_for('static', filename='models/ply/binary/new_room_edited.ply') }}";

			var state = {
				renderPose : false
			};

			function initHuman() {
				var joints = [];
				var limbs = [];

				// create geometry for joints
				for (var i=0; i<jointColors.length; i++) {
					
					// initialize joint points
					
					var jointColor = jointColors[i];
					var jointColorHex = fullColorHex(jointColor[0], jointColor[1], jointColor[2]);
					jointColorHex = new THREE.Color(parseInt(jointColorHex, 16));

					// var jointGeometry = new THREE.Geometry();
					// var jointMaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false });
					// jointMaterial.color = jointColorHex;
					// jointGeometry.colors = jointColorHex;
					// jointGeometry.computeBoundingBox();
					// var joint = new THREE.Points( jointGeometry, jointMaterial );
					// joint.scale.set( 10,10,10 );
					
					var geometry = new THREE.SphereGeometry( 0.3, 8, 8 );
					var material = new THREE.MeshBasicMaterial( {color: jointColorHex} );
					var joint = new THREE.Mesh(geometry, material);

					
					renderGroup.add(joint);

					joints.push(joint);

				}
				
				for (var j=0; j<limbConnections.length; j++) {
					var connectionPair = limbConnections[j];
					var n1 = connectionPair[0];
					var n2 = connectionPair[1];

					var v1 = joints[n1].position;
					var v2 = joints[n2].position;

					var lineColor = limbColors[j];
					var lineColorHex = fullColorHex(lineColor[0], lineColor[1], lineColor[2]);
					lineColorHex = new THREE.Color(parseInt(lineColorHex, 16));

					var lineGeometry = new THREE.Geometry();
					lineGeometry.vertices.push(v1);
					lineGeometry.vertices.push(v2);
					lineGeometry.dynamic = true;
					lineGeometry.verticesNeedUpdate = true;

					var lineMaterial = new THREE.LineBasicMaterial( { color: lineColorHex, opacity: 0.5, linewidth: 3 } );
					var line = new THREE.Line(lineGeometry, lineMaterial);

					renderGroup.add(line);

					limbs.push(line);
				}

				jointGroup.push(joints);
				limbGroup.push(limbs);
			}

			function updateJoints(index, pose) {
				// call this function when new pose needs to be added
				
				for (var i=0; i<jointColors.length; i++) {
					var id = i.toString();
					if (typeof pose[id] === "undefined") {
						jointGroup[index][i].visible = false;
					}
					else {
						var x = pose[id][0];
						var y = pose[id][1];
						var z = pose[id][2];

						jointGroup[index][i].visible = true;
						jointGroup[index][i].position.set(x, y, z);
					}
				}
				
				// update line
				var ids = Object.keys(pose);
				for (var j=0; j<limbConnections.length; j++) {
					var n1 = limbConnections[j][0].toString();
					var n2 = limbConnections[j][1].toString();

					limbGroup[index][j].geometry.verticesNeedUpdate = true;
					limbGroup[index][j].computeLineDistances();
					if (ids.includes(n1) && ids.includes(n2)) {
						
						limbGroup[index][j].visible = true;
					} else {
						limbGroup[index][j].visible = false;
					}
				}

			}

			function getNewPosition(callback) {
				socket.emit('want pose', {data: 'give me pose'}, gotNewPosition);
				// socket.once('send pose', function( msg ) {
				// 	ack();
				// 	callback(msg);
				// });
			}

			function gotNewPosition(newPoses) {
				if (typeof newPoses === "undefined") {
					console.log("something is wrong");
				} else {
					var jsonPoses = JSON.parse(newPoses);

					for (var key in jsonPoses) {

						var i = Number(key);
						var pose = jsonPoses[key];

						// if (i+1 > jointGroup.length) {
						// 	initHuman();
						// 	console.log("new pose")
						// }

						if (i === 0) {
							// only a single person for now
							updateJoints(i, pose);
						}
						
					}

				}
			}
			
			function animate(now) {  // requestAnimationFrame has a call back for time (which is `now`)
				// calls two seconds
				if(!last || now - last >= interval*1000) {
					last = now;
					//console.log(now);
					if (state.renderPose) {
						getNewPosition(gotNewPosition);
					}
				}

				requestAnimationFrame( animate );
				
				renderer.render( scene, camera );
				stats.update();
			}
			

			initThreeD(roomModelURL);
			
			setupDatGui();
			initHuman();
			animate();

		</script>

	</body>
</html>